# -*- coding: utf-8 -*-
"""Cópia de Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NzO5j_Er1lxT-n5BIVo_Y8Nv0i9T0Z9w
"""

import requests
from bs4 import BeautifulSoup
import pandas as pd
import matplotlib.pyplot as plt
import logging

# Constantes
URL_LOGIN = "https://smartnet.sgp.tsmx.com.br/accounts/login/"
URL_BUSCA1 = "https://smartnet.sgp.tsmx.com.br/admin/financeiro/relatorios/titulo/emitidos/"
URL_BUSCA2 = "https://smartnet.sgp.tsmx.com.br/admin/financeiro/relatorios/titulo/recebidos/"
URL_BUSCA3 = "https://smartnet.sgp.tsmx.com.br/admin/financeiro/relatorios/titulo/areceber/"

# Dados de login
USUARIO = "guilhermealves"
SENHA = "88412594"

# Dados da busca
DATA_INICIAL = "01/11/2024"
DATA_FINAL = "30/11/2024"

# Função para fazer login
def fazer_login(usuario: str, senha: str) -> requests.Response:
    try:
        response = requests.post(URL_LOGIN, data={"username": usuario, "password": senha}, timeout=10)
        response.raise_for_status()
        return response
    except requests.exceptions.ConnectionError as e:
        logging.error(f"Erro de conexão: {e}")
        return None

# Função para fazer buscas
def fazer_busca(response: requests.Response, url: str, params: dict) -> requests.Response:
    try:
        response = requests.get(url, params=params, cookies=response.cookies, timeout=10)
        response.raise_for_status()
        return response
    except requests.exceptions.ConnectionError as e:
        logging.error(f"Erro de conexão: {e}")
        return None

# Função para extrair dados das tabelas
def extrair_dados(tabela: BeautifulSoup) -> pd.DataFrame:
    dados = []
    for linha in tabela.find_all("tr"):
        cols = linha.find_all("td")
        if len(cols) > 0:
            dados.append([col.text.strip() for col in cols])
    return pd.DataFrame(dados)

# Função para criar gráficos
def criar_graficos(titulos_pendentes: pd.DataFrame, titulos_recebidos: pd.DataFrame, titulos_total: pd.DataFrame) -> None:
    # Somar os valores dos pagamentos
    soma_valores_recebidos = 0
    for index, row in titulos_recebidos.iterrows():
        valor = row['Valor Pago'].replace('.', '', 1).replace(',', '.', 1)
        if valor.replace('.', '', 1).isdigit():
            soma_valores_recebidos += float(valor)

    # Somar os valores totais
    soma_valores_total = 0
    for index, row in titulos_total.iterrows():
        valor = row['Valor'].replace('.', '', 1).replace(',', '.', 1)
        if valor.replace('.', '', 1).isdigit():
            soma_valores_total += float(valor)

    # Somar os valores pendentes
    soma_valores_pendentes = 0
    for index, row in titulos_pendentes.iterrows():
        valor = row[titulos_pendentes.columns[5]].replace('.', '', 1).replace(',', '.', 1)
        if valor.replace('.', '', 1).isdigit():
            soma_valores_pendentes += float(valor)

    # Criar gráficos
    valor_total = soma_valores_total
    valor_recebido = soma_valores_recebidos
    valor_pendente = soma_valores_pendentes
    porcentagem_recebido = (valor_recebido / valor_total) * 100
    porcentagem_pendente = (valor_pendente / valor_total) * 100

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))

    ax1.bar(['Total', 'Recebido', 'Pendente'], [valor_total, valor_recebido, valor_pendente])
    ax1.set_xlabel('Categoria')
    ax1.set_ylabel('Valor (R$)')
    ax1.set_title('Receitas de Novembro')
    ax1.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, loc: f"R${x:.2f}"))

    tamanho_total = 100
    tamanho_recebido = int((valor_recebido / valor_total) * tamanho_total)
    tamanho_pendente = tamanho_total - tamanho_recebido

    ax2.axhline(0.7, xmin=0, xmax=tamanho_total/100, color='blue', linewidth=10, label='Título a receber total')
    ax2.axhline(0.5, xmin=0, xmax=tamanho_recebido/100, color='green', linewidth=10, label=f'Título recebido: {porcentagem_recebido:.2f}%')
    ax2.axhline(0.3, xmin=0, xmax=tamanho_pendente/100, color='red', linewidth=10, label=f'Título a receber pendente: {porcentagem_pendente:.2f}%')

    ax2.text(0.5, 0.8, f'Título a receber total: R${valor_total:.2f}', ha='center', fontsize=14)
    ax2.text(0.5, 0.6, f'Título recebido: R${valor_recebido:.2f}', ha='center', fontsize=14)
    ax2.text(0.5, 0.4, f'Título a receber pendente: R${abs(valor_pendente):.2f}', ha='center', fontsize=14)

    ax2.set_axis_off()
    ax2.set_title('Resumo das Receitas')
    ax2.legend(loc='upper right')

    plt.tight_layout()
    plt.show()

    # Mostrar o resumo das receitas
    print('Resumo das Receitas:')
    print(f'Títulos a Receber Total: R${valor_total:.2f}')
    print(f'Títulos Recebidos: R${soma_valores_recebidos:.2f}')
    print(f'Títulos a Receber Pendente: R${abs(soma_valores_pendentes):.2f}')

# Função principal
def main() -> None:
    response = fazer_login(USUARIO, SENHA)
    if response is None:
        logging.error("Erro ao fazer login")
        return

    params1 = {
        "reqtime": "20241128233953",
        "dpb_token": "02ba1923822ed6513d8d6beab81685f3",
        "razaosocial": "",
        "tipo_cliente": "",
        "portador": "",
        "gateway_pagamento": "",
        "grupo": "",
        "nas": "",
        "torre": "",
        "data_ini": "",
        "data_fim": "",
        "data_venc_ini": DATA_INICIAL,
        "data_venc_fim": DATA_FINAL,
        "data_cad_contrato_ini": "",
        "data_cad_contrato_fim": "",
        "usuario": "",
        "status_titulo": ["1", "2"],
        "com_api": "",
        "com_pix": "",
        "id_remessa": "",
        "id_remessagateway": "",
        "com_remessa": "",
        "valor": "",
        "status_contrato": "",
        "vendedor": "",
        "titulos_nota": "",
        "titulos_nfse": "",
        "page": "",
        "printpdf": "",
        "printexcel": ""
    }

    params2 = {
        "reqtime": "20241128230720",
        "dpb_token": "df7e1ed519839fc00bbcbdfc5224db66",
        "razaosocial": "",
        "tipo_cliente": "",
        "portador": "",
        "gateway_pagamento": "",
        "grupo": "",
        "nas": "",
        "torre": "",
        "data_ini": DATA_INICIAL,
        "data_fim": DATA_FINAL,
        "data_venc_ini": "",
        "data_venc_fim": "",
        "data_cad_contrato_ini": "",
        "data_cad_contrato_fim": "",
        "usuario": "",
        "com_api": "",
        "com_pix": "",
        "id_remessa": "",
        "id_remessagateway": "",
        "com_remessa": "",
        "valor": "",
        "status_contrato": "",
        "vendedor": "",
        "titulos_nota": "",
        "titulos_nfse": "",
        "tipo_data": "pagamento",
        "pontorecebimento": "",
        "modobaixa": "",
        "retornobanco": "",
        "printpdf": "",
        "printexcel": "",
        "page": "",
        "data_p_ini": DATA_INICIAL,
        "data_p_fim": DATA_FINAL
    }

    params3 = {
        "reqtime": "20241128212806",
        "dpb_token": "3cb27e556e7de345be2bf4a3aa188a31",
        "razaosocial": "",
        "tipo_cliente": "",
        "empresas": "1",
        "pops": "1",
        "portador": "",
        "grupo": "",
        "nas": "",
        "torre": "",
        "data_venc_ini": DATA_INICIAL,
        "data_venc_fim": DATA_FINAL,
        "usuario": "",
        "com_api": "",
        "com_pix": "",
        "id_remessa": "",
        "com_remessa": "",
        "valor": "",
        "vendedor": "",
        "titulos_nota": "",
        "printpdf": "",
        "printexcel": "",
        "page": ""
    }

    response1 = fazer_busca(response, URL_BUSCA1, params1)
    response2 = fazer_busca(response, URL_BUSCA2, params2)
    response3 = fazer_busca(response, URL_BUSCA3, params3)

    if response1 is None or response2 is None or response3 is None:
        logging.error("Erro ao fazer busca")
        return

    tabela1 = BeautifulSoup(response1.content, "html.parser")
    tabela2 = BeautifulSoup(response2.content, "html.parser")
    tabela3 = BeautifulSoup(response3.content, "html.parser")

    titulos_total = extrair_dados(tabela1)
    titulos_recebidos = extrair_dados(tabela2)
    titulos_pendentes = extrair_dados(tabela3)

    # Verificar se os DataFrames estão vazios
    if not titulos_total.empty:
        titulos_total.columns = ["Cliente", "ID", "Data Vencimento", "Data Emissão", "Tipo", "Status", "Valor", "Valor Pago", "Plano", "ID Plano", "Observações"]
    if not titulos_recebidos.empty:
        titulos_recebidos.columns = ["Cliente", "ID", "Data Pagamento", "Data Emissão", "Tipo", "Status", "Valor", "Valor Pago", "Plano", "ID Plano", "Observações", "Coluna 12", "Coluna 13", "Coluna 14"]
    if not titulos_pendentes.empty:
        # Atribuir nomes às colunas do DataFrame titulos_pendentes
        titulos_pendentes.columns = [f"Coluna {i}" for i in range(len(titulos_pendentes.columns))]

    criar_graficos(titulos_pendentes, titulos_recebidos, titulos_total)

if __name__ == "__main__":
    main()

from google.colab import drive
drive.mount('/content/drive')

import plotly.express as px
import pandas as pd
import requests
from bs4 import BeautifulSoup
from datetime import datetime

# Dados de login
usuario = "guilhermealves"
senha = "88412594"

# URL da página
url_login = "https://smartnet.sgp.tsmx.com.br/accounts/login/"
url_busca = "https://smartnet.sgp.tsmx.com.br/admin/financeiro/relatorios/titulo/recebidos/"

# Função para buscar os dados
def buscar_dados(datas_busca):
    valores = []
    for dados_busca in datas_busca:
        # Fazer login
        response = requests.post(url_login, data={"username": usuario, "password": senha}, timeout=10)

        # Verificar se o login foi bem-sucedido
        if response.status_code == 200:
            # Fazer busca
            response_busca = requests.get(url_busca, params={
                "reqtime": "20241128230720",
                "dpb_token": "df7e1ed519839fc00bbcbdfc5224db66",
                "razaosocial": "",
                "tipo_cliente": "",
                "portador": "",
                "gateway_pagamento": "",
                "grupo": "",
                "nas": "",
                "torre": "",
                "data_ini": dados_busca["ini"],
                "data_fim": dados_busca["fim"],
                "data_venc_ini": "",
                "data_venc_fim": "",
                "data_cad_contrato_ini": "",
                "data_cad_contrato_fim": "",
                "usuario": "",
                "com_api": "",
                "com_pix": "",
                "id_remessa": "",
                "id_remessagateway": "",
                "com_remessa": "",
                "valor": "",
                "status_contrato": "",
                "vendedor": "",
                "titulos_nota": "",
                "titulos_nfse": "",
                "tipo_data": "pagamento",
                "pontorecebimento": "",
                "modobaixa": "",
                "retornobanco": "",
                "printpdf": "",
                "printexcel": "",
                "page": "",
                "data_p_ini": dados_busca["ini"],
                "data_p_fim": dados_busca["fim"]
            }, cookies=response.cookies, timeout=10)

            # Verificar se a busca foi bem-sucedida
            if response_busca.status_code == 200:
                # Extrair os dados da tabela
                soup = BeautifulSoup(response_busca.content, "html.parser")
                tabela = soup.find("table")

                # Verificar se a tabela foi encontrada
                if tabela is not None:
                    dados = []
                    for linha in tabela.find_all("tr"):
                        cols = linha.find_all("td")
                        if len(cols) > 0:
                            dados.append([col.text.strip() for col in cols])

                    # Criar um DataFrame com os dados
                    df = pd.DataFrame(dados)

                    # Verificar se o DataFrame tem dados
                    if not df.empty:
                        # Verificar se o DataFrame tem as colunas necessárias
                        if len(df.columns) >= 8:
                            # Criar um novo DataFrame com apenas as colunas necessárias
                            colunas = df.columns
                            df_novo = df.iloc[:, [0, 7]]  # Pegar a coluna 0 (cliente) e 7 (valor pago)

                            # Resetar o índice do DataFrame
                            df_novo = df_novo.reset_index(drop=True)

                            # Renumerar o índice do DataFrame
                            df_novo.index += 1

                            # Somar os valores pagos
                            soma_valores_pagos = 0
                            for index, row in df_novo.iterrows():
                                valor_pago = row.iloc[1].replace('.', '', 1).replace(',', '.', 1)
                                if valor_pago.replace('.', '', 1).isdigit():
                                    soma_valores_pagos += float(valor_pago)

                            valores.append(soma_valores_pagos)
                        else:
                            valores.append(0)
                    else:
                        valores.append(0)
                else:
                    valores.append(0)
            else:
                valores.append(0)
        else:
            valores.append(0)
    return valores

# Dados da busca
agora = datetime.now()
mes_atual = agora.month
ano_atual = agora.year

datas_busca_atual = [
    {"ini": f"01/{mes_atual:02}/{ano_atual}", "fim": f"07/{mes_atual:02}/{ano_atual}", "titulo": "Semana 1"},
    {"ini": f"08/{mes_atual:02}/{ano_atual}", "fim": f"14/{mes_atual:02}/{ano_atual}", "titulo": "Semana 2"},
    {"ini": f"15/{mes_atual:02}/{ano_atual}", "fim": f"21/{mes_atual:02}/{ano_atual}", "titulo": "Semana 3"},
    {"ini": f"22/{mes_atual:02}/{ano_atual}", "fim": f"{agora.day:02}/{mes_atual:02}/{ano_atual}", "titulo": "Semana 4"}
]

valores_atual = buscar_dados(datas_busca_atual)

# Criar um DataFrame com os dados do mês atual
df_atual = pd.DataFrame({
    "semana": [f"Semana {i+1}" for i in range(len(datas_busca_atual))],
    f"{mes_atual}/{ano_atual}": valores_atual
})

# Criar um gráfico de colunas
fig_semanal = px.bar(x=df_atual["semana"], y=df_atual[f"{mes_atual}/{ano_atual}"], title=f"Gráfico de Colunas Semanais {mes_atual}/{ano_atual}",
                     color=df_atual["semana"],  # Cor das colunas será definida pela semana
                     color_discrete_sequence=["red", "blue", "green", "yellow"],  # Paleta de cores
                     text=[f"R${valor:,.2f}" for valor in valores_atual])

# Adicionar anotações com a data
for i, row in df_atual.iterrows():
    fig_semanal.add_annotation(x=row['semana'], y=row[f'{mes_atual}/{ano_atual}'], text=row['semana'], showarrow=False, yshift=-20)

# Atualizar o layout do gráfico
fig_semanal.update_layout(
    showlegend=False,
    xaxis_title_text='Semana',
    yaxis_title_text='Valor'
)

# Mostrar o gráfico semanal
fig_semanal.show()

# Dados da busca do mês anterior
if mes_atual == 1:
    mes_anterior = 12
    ano_anterior = ano_atual - 1
else:
    mes_anterior = mes_atual - 1
    ano_anterior = ano_atual

datas_busca_anterior = [
    {"ini": f"01/{mes_anterior:02}/{ano_anterior}", "fim": f"07/{mes_anterior:02}/{ano_anterior}", "titulo": "Semana 1"},
    {"ini": f"08/{mes_anterior:02}/{ano_anterior}", "fim": f"14/{mes_anterior:02}/{ano_anterior}", "titulo": "Semana 2"},
    {"ini": f"15/{mes_anterior:02}/{ano_anterior}", "fim": f"21/{mes_anterior:02}/{ano_anterior}", "titulo": "Semana 3"},
    {"ini": f"22/{mes_anterior:02}/{ano_anterior}", "fim": f"31/{mes_anterior:02}/{ano_anterior}", "titulo": "Semana 4"}
]

valores_anterior = buscar_dados(datas_busca_anterior)

# Criar um DataFrame com os dados dos dois meses
df = pd.DataFrame({
    "semana": [f"Semana {i+1}" for i in range(len(datas_busca_atual))],
    f"{mes_anterior}/{ano_anterior}": valores_anterior,
    f"{mes_atual}/{ano_atual}": valores_atual
})

# Calcular a variação em %
df[f'variação_{mes_anterior}_{ano_anterior}_{mes_atual}_{ano_atual}'] = ((df[f'{mes_atual}/{ano_atual}'] - df[f'{mes_anterior}/{ano_anterior}']) / df[f'{mes_anterior}/{ano_anterior}']) * 100

# Criar gráfico de colunas
fig_colunas = px.bar(df, x="semana", y=[f"{mes_anterior}/{ano_anterior}", f"{mes_atual}/{ano_atual}"], title=f"Gráfico de Colunas {mes_anterior}/{ano_anterior} e {mes_atual}/{ano_atual}", barmode="group", color_discrete_sequence=["blue", "red"])

# Adicionar legenda de variação
for i, row in df.iterrows():
    if row[f'variação_{mes_anterior}_{ano_anterior}_{mes_atual}_{ano_atual}'] > 0:
        legenda = f"Aumento de {row[f'variação_{mes_anterior}_{ano_anterior}_{mes_atual}_{ano_atual}']:.2f}%"
    elif row[f'variação_{mes_anterior}_{ano_anterior}_{mes_atual}_{ano_atual}'] < 0:
        legenda = f"Diminuição de {abs(row[f'variação_{mes_anterior}_{ano_anterior}_{mes_atual}_{ano_atual}']):.2f}%"
    else:
        legenda = "Estável"

    fig_colunas.add_annotation(x=row['semana'], y=row[f'{mes_atual}/{ano_atual}'], text=legenda, showarrow=False, yshift=20)

# Atualizar legendas
fig_colunas.update_layout(
    legend_title_text='Meses',
    xaxis_title_text='Semana',
    yaxis_title_text='Valor',
    legend=dict(
        orientation="h",
        yanchor="bottom",
        y=1.02,
        xanchor="right",
        x=1
    )
)

# Renomear legendas
fig_colunas.data[0].name = f'{mes_anterior} {ano_anterior}'
fig_colunas.data[1].name = f'{mes_atual} {ano_atual}'

# Mostrar gráfico
fig_colunas.show()

# Criar um loop para iterar sobre cada dia do mês
dias_mes = []
valores_diarios = []
for dia in range(1, agora.day + 1):
    data_ini = f"{dia:02}/{mes_atual:02}/{ano_atual}"
    data_fim = f"{dia:02}/{mes_atual:02}/{ano_atual}"
    valor_diario = buscar_dados([{"ini": data_ini, "fim": data_fim}])[0]
    dias_mes.append(data_ini)
    valores_diarios.append(valor_diario)

# Criar um DataFrame com os dados diários
df_diarios = pd.DataFrame({
    "Dia": dias_mes,
    "Valor Diário": valores_diarios
})

# Criar um gráfico de barras com linha
fig_barras_diarias = px.bar(df_diarios, x="Dia", y="Valor Diário", title="Valores Diários", text_auto=True, color_discrete_sequence=["green"])

# Adicionar linha que conecta os picos
fig_barras_diarias.add_scatter(x=df_diarios["Dia"], y=df_diarios["Valor Diário"], mode="lines", line=dict(color="blue", width=3, dash="solid"))

# Mostrar o gráfico
fig_barras_diarias.show()

